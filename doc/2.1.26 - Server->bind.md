# Server->bind

将连接绑定一个用户定义的`UID`，可以设置`dispatch_mode=5`设置以此值进行`hash`固定分配。可以保证某一个`UID`的连接全部会分配到同一个`Worker`进程。

```php
function Server->bind(int $fd, int $uid);
```

* `$fd`：连接的`ID`
* `$uid`：要绑定的`UID`，必须为非`0`的数字
* 未绑定`UID`时默认使用`fd`取模进行分配

> 同一个连接只能被`bind`一次，如果已经绑定了`UID`，再次调用`bind`会返回`false`   
> 可以使用`$serv->getClientInfo($fd)` 查看连接所绑定`UID`的值  
> 仅在设置`dispatch_mode=5`时有效

在默认的`dispatch_mode=2`设置下，`Server`会按照`socket fd`来分配连接数据到不同的`Worker`进程。因为`fd`是不稳定的，一个客户端断开后重新连接，`fd`会发生改变。这样这个客户端的数据就会被分配到别的`Worker`。使用`bind`之后就可以按照用户定义的`UID`进行分配。即使断线重连，相同`UID`的`TCP`连接数据会被分配相同的`Worker`进程。

时序问题
----
客户端连接服务器后，连续发送多个包，可能会存在时序问题。在`bind`操作时，后续的包可能已经`dispatch`，这些数据包仍然会按照`fd`取模分配到当前进程。只有在`bind`之后新收到的数据包才会按照`UID`取模分配。

因此如果要使用`bind`机制，网络通信协议需要设计握手步骤。客户端连接成功后，先发一个握手请求，之后客户端不要发任何包。在服务器`bind`完后，并回应之后。客户端再发送新的请求。

重新绑定
----
某些情况下，业务逻辑需要用户连接重新绑定`UID`。这时可以切断连接，重新建立`TCP`连接并握手，绑定到新的`UID`。

